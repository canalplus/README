[{"file":"./Getting_Started/Home.html","index":[{"h1":"README","body":"","anchorH1":"readme"},{"h1":"README","h2":"Overview","body":"README is a very simple HTML documentation generator whose goal is to be as pain-free as possible to put in place, maintain and navigate. When relying on README, all you need to do is:   To write your documentation files in the same Markdown format you’re used to (the full ubiquitous CommonMark syntax is handled, with no added special syntax). Note that links, including those between Markdown files, are handled, as well as things like embedded image, video and audio resources.   Put them in directories following a file tree architecture reflecting your wanted HTML documentation (categories in different directories, page groups as pages in the same subdirectory).   Add .docConfig.json files in the resulting directories and sub-directories to set-up configuration and indicate the pages’ ordering.   Then you can run README on it to generate static HTML files which can directly be served as your documentation. That’s it!","anchorH1":"readme","anchorH2":"overview"},{"h1":"README","h2":"Installation","body":"README is installable through your favorite node package manager (npm / yarn / pnpm) by installing the @canalplus/readme.doc package: # through npm npm install @canalplus/readme.doc --save-dev  # or through yarn yarn add @canalplus/readme.doc --dev  You should then be able to run it by referencing through its readme.doc name in a package.json script or through npx. To ensure the readme.doc is accessible, you can try running it with the -v flag and see if the right version is outputed: # Outputs README version npx --no -- readme.doc -v  # Note: The `--no --` part in that npx command is there to ensure that README # has been installed locally with success. # If you see the expected version outputed, it is correctly installed and # it is equivalent to just calling `npx readme.doc -v`. ","anchorH1":"readme","anchorH2":"installation"},{"h1":"README","h2":"Usage","body":"Then producing your HTML documentation pages is straightforward. Before going deep into all steps one by one, here is a brief description for each one of them:   Documentation Files: Write documentation files in Markdown in a file tree architecture respecting the same structure you want in your HTML documentation (e.g. Getting Started pages in a given directory, API pages in another etc.).   Configuration: Add a .docConfig.json file, setting the documentation’s global configuration, in your documentation’s root directory   Page Listing: Add .docConfig.json files in each sub-directories to set the order of documentation pages as well as their name.   Run: Run the readme.doc command.   Serve: Serve the corresponding generated HTML pages.  ","anchorH1":"readme","anchorH2":"usage"}]},{"file":"./Getting_Started/Steps/Documentation_Files.html","index":[{"h1":"Documentation Files","body":"","anchorH1":"documentation-files"},{"h1":"Documentation Files","h2":"Overview","body":"In this page, we’re going to focus on how you will want to write your documentation files and where to place them in your project, depending on the wanted resulting documentation.","anchorH1":"documentation-files","anchorH2":"overview"},{"h1":"Documentation Files","h2":"Format","body":"","anchorH1":"documentation-files","anchorH2":"format"},{"h1":"Documentation Files","h2":"Format","h3":"CommonMark Markdown","body":"All documentation pages you want to generate HTML pages for have to written in the Markdown format (which generally ends with the .md extension), more specifically respecting the CommonMark specification, which is its most popular specified implementation. If you’re not familiar with the Markdown format, you can follow the CommonMark tutorial linked here.","anchorH1":"documentation-files","anchorH2":"format","anchorH3":"commonmark-markdown"},{"h1":"Documentation Files","h2":"Format","h3":"About relying on plain Markdown files","body":"Markdown files have the huge advantages of being both human-readable and compatible to a large panel of developer-facing applications and tools. It can also be noted than most forges (GitHub, GitLab, SourceHut, BitBucket etc.) provide a very good support of the format natively, making it one of the strongest format candidate for developer-oriented documentation files. Though README generates HTML files, the source Markdown files are also intended to be readable as is, by any of those tools, which is why we renounce at the idea of adding any specific syntax. Let’s consider your projects’ developers as an example. They probably will end up reading much more often the source Markdown files (e.g. when re-checking some API details in the documentation) than viewing it through its URL in a web browser. And this can be extrapolated to some users as well.","anchorH1":"documentation-files","anchorH2":"format","anchorH3":"about-relying-on-plain-markdown-files"},{"h1":"Documentation Files","h2":"Content","body":"","anchorH1":"documentation-files","anchorH2":"content"},{"h1":"Documentation Files","h2":"Content","h3":"How much information to put in it","body":"Each of the Markdown files you’ll write will correspond to a single documentation page once transformed by README. You should keep that in mind when writing your documentation to get a feeling of what information to put in a file and when another file should be created instead. For example, this Documentation Files documentation page is written in a single Markdown source page, here: TODO As you can see, its content is just straightforward human-readable Markdown, with headings, links, code, emphasis and all of the other features you may be used to if you relied on Markdown before.","anchorH1":"documentation-files","anchorH2":"content","anchorH3":"how-much-information-to-put-in-it"},{"h1":"Documentation Files","h2":"Content","h3":"Table of contents","body":"You may have noticed that there is a table of contents in the right-side of this page. This table of content is automatically generated by README by relying on “headings” (those either defined by # characters or setext headings) declared in your documentation files. Levels 1 (a single # or a =====-style setext heading), 2 (2 # characters or ------style setext heading) and 3 (3 # characters) are all considered to generate it. For example this page has Documentation Files as its only level 1 headers, multiple level 2 headers such as Overview and Format, and multiple level 3 headers such as CommonMark Markdown and Code blocks.","anchorH1":"documentation-files","anchorH2":"content","anchorH3":"table-of-contents"},{"h1":"Documentation Files","h2":"Content","h3":"Embedded HTML","body":"As permitted by the CommonMark specification, you can embed HTML in your documentation pages to have close to endless ways of expressing a layout. For example: <p style=\"text-align: center; border: 1px dashed #444\">   Some <i>embedded HTML</i> block </p>  Will render as:      Some embedded HTML block  The treatment of HTML follows the exact rules of the CommonMark specification on HTML blocks so you should rest assured that most other tools (e.g. GitLab, GitHub, Prettier, editor extensions…) should have no problem handling them. Still, keep in mind that embedded raw HTML blocks are harder to read when the original markdown is viewed than the simpler Markdown syntax.","anchorH1":"documentation-files","anchorH2":"content","anchorH3":"embedded-html"},{"h1":"Documentation Files","h2":"Content","h3":"Code blocks","body":"Again, code blocks syntax just follows here the CommonMark specification. You may already be used to using backticks (`) for “code spans” and triple backticks for “code fences”. For example: “`this`” will be transformed into “this”, and that multiline code:  ``` function print() {     console.log(\"Hello world!\"); } ```  Will be transformed into: function print() {     console.log(\"Hello world!\"); }  README also includes a syntax highlighter, highlight.js, which will automatically hightlight your code based on the language you associated to your code fence. For example (notice the js mention, which can also be written as javascript by the way):  ```js function print() {     console.log(\"Hello world!\"); } ```  Will be transformed into: function print() {   console.log(\"Hello world!\"); } ","anchorH1":"documentation-files","anchorH2":"content","anchorH3":"code-blocks"},{"h1":"Documentation Files","h2":"Content","h3":"Links to other markdown files","body":"You can add a link to another Markdown file in your documentation pages in which case the link will be automatically translated to a link to the corresponding documentation page in the HTML output. For example: Here's a [link to the configuration page](./Configuration.md).  Will be translated to:  Here’s a link to the configuration page.  Note: If a linked relative Markdown file is not found by README, it will output a warning at the Run step. This allows to make sure that you wrote your links between documentation pages correctly.","anchorH1":"documentation-files","anchorH2":"content","anchorH3":"links-to-other-markdown-files"},{"h1":"Documentation Files","h2":"Content","h3":"Link anchors","body":"You can also directly link to a heading (from level 1 to 3), by adding its name in the URL’s fragment (after a # character). To be compatible with URL fragments, the header names are actually updated in a simple way:   All spaces at the beginning or end of the title are removed.   Remaining spaces are replaced by a dash (-).   Every characters not part of any of those sets:  Upper-case latin letters from A to Z Lower-case latin letters from a to z dashes (-) underscores (_)  Will be removed when put as an anchor.   All remaining upper-case aphabetical characters (A to Z), is transformed to a lower-case character (a to z).   As such, if you want to link to the Code blocks chapter of this page, you can link to it like this: [link](#code-blocks) (we replaced the space by a dash character and set the title in lower case). Here’s the result for this example: link To select a more complex example, to link an heading like this: ##    Bonne année à tous  , you would write something like [some link](#bonne-anne--tous) (The ending space is removed, the middle spaces replaced by dashes, the B is transformed into lower-case b and both the é an à are removed). For most use-cases (and at least for english headings), doing anchor generation this way is generally compatible to how tools like GitHub and GitLab also generate their headings, leading to anchor links in Markdown files that are still functional in those tools. Duplicated headings in the same page should be avoided. If README see two conflicting anchors, it will add a numerical postfix starting with the second one encountered. If such scenarios is unavoidable, you may prefer to generate the documentation pages once to check the resulting anchor names before linking to it. Last but not least it is perfectly possible to link to an anchor in another Markdown page. As such, [example](../Home.md#installation) will directly jump to the Installation chapter of the Home.html page: example.","anchorH1":"documentation-files","anchorH2":"content","anchorH3":"link-anchors"},{"h1":"Documentation Files","h2":"Content","h3":"Image, audio and video","body":"When linking to a media resource, either through Markdown syntax’s for images or through embedded HTML elements, README will automatically copy the resouce so it is also accessible from the output directory. For example, I can insert an image by writing something like ![README logo](../../assets/img/logo.png \"README\"), which will copy the image so it is visible in the HTML page. Likewise, media elements like <video src=\"../../assets/video/my_video.mp4\" /> can be embedded in you markdown as HTML. The resource will also be copied by README into the output directory. README only copies local resources. You can also refer to online resources in your markdown files, in which case the resulting HTML will also refer to those same online resources without copying them locally.","anchorH1":"documentation-files","anchorH2":"content","anchorH3":"image-audio-and-video"},{"h1":"Documentation Files","h2":"File and directories location","body":"The location of the various directories containing documentation pages is important, as the file architecture will be reused by README to organize the generated HTML pages. All documentation pages should be put in a common root directory in your project. To take an example, let’s say that our root directory is ./doc (from the root of our project). In that root directory, you want to put subdirectories corresponding to the “Categories” you’ll have. Categories are subsets of your documentations which you do not want to group together (for example in this documentation, categories are “Getting Started” and “API”). You do not need to name the directory the same way you want the category to be called in the resulting HTML documentation, this “display name” will be configurable in the Configuration step. Inside that second level of directories (the “Category” ones), you can either put directly your Markdown documentation pages, or directories themselves containing Markdown documentation pages if you want to create multiple linked pages in a “page groups” (in the documentation you’re reading right now the “Step by step guide” is a page group for example). Once again, the name of those files and directories aren’t important as the name used for display in links will be configured elsewhere. Likewise, the order in which those files may be listed (alphabetically or otherwise) is unimportant. You’ll set-up configuration files in the next steps setting a clear ordering of those pages. Thus, taking in example the README documentation you’re reading right now, here’s how files have been organized (may be out-of-date): doc                                  # Root directory │ ├── .docConfig.json                  # Global configuration (we'll see that later) │ ├── Getting_Started                  # \"Getting Started\" Category │   ├── .docConfig.json              # Local configuration (we'll see that later) │   ├── Steps                        # Page group │   │   ├── .docConfig.json          # Local configuration │   │   ├── Configuration.md │   │   ├── Documentation_Files.md   # The page you're reading right now │   │   ├── Page_Ordering.md │   │   ├── Run.md │   │   └── Serve.md │   ├── Home.md                      # The \"README Overview\" previous page │   └── HTML_Page_features.md │ └── API                              # Another Category, \"API\"     ├── .docConfig.json              # Local configuration     ├── CLI.md     └── ... ","anchorH1":"documentation-files","anchorH2":"file-and-directories-location"}]},{"file":"./Getting_Started/Steps/Configuration.html","index":[{"h1":"Configuration","body":"","anchorH1":"configuration"},{"h1":"Configuration","h2":"Root configuration overview","body":"Now that you know how to write your documentation files, and chose a root directory where to put them, you’ll need to indicate to README how you want your documentation to be generated:   To indicate how your documentation is divided. For example you might have a “Getting Started”, a “Tutorial”, an “API” and/or a “Reference” that you want to keep separated on the produced documentation.   To add external links, such as to your repository, to your demo or to a blog   To display a logo for your project, add a favicon etc.   All of this is done with a .docConfig.json file to put at your project documentation’s root directory.","anchorH1":"configuration","anchorH2":"root-configuration-overview"},{"h1":"Configuration","h2":"Format and properties","body":"As its extension suggests, .docConfig.json is a JSON file. Here is a completely documented and exhaustive example of one. Note that all properties indicated as “optional” can be omitted: {   // Optional object to define a logo which will be located on the top left of   // each page. That logo is optionally a link to some other page, depending if   // its `link` property below is defined.   \"logo\": {     // Local path (can be relative to the current directory) to the image of the     // logo     \"srcPath\": \"./images/logo.png\",      // Optional link to redirect to when the logo is clicked. Can be ignored in     // which case the logo is not clickable     \"link\": \"https://homepageoftheproject.html\"   },    // Optional object to define a favicon for the documentation pages   \"favicon\": {     // Local path (can be relative to the current directory) to the image of the     // favicon     \"srcPath\": \"./images/favicon.ico\"   },    // Links available at the top of the page, on the left-side of it from left to   // right.   //   // Each of those items will have a format which is dependant on its `\"type\"`   // property. We'll look over all possibilities.   \"linksLeft\": [     {       // `\"local-doc\"` are relative links to where your markdown documentation       // is. You can see below more information on how you can organize the       // corresponding directory.       \"type\": \"local-doc\",        // Relative path to that directory.       \"path\": \"./Getting_Started\",        // Name displayed for the link to that directory on the generated HTML pages.       \"displayName\": \"Getting Started\"     },     {       \"type\": \"local-doc\",       \"path\": \"./api\",       \"displayName\": \"API\"     },     {       // `\"link\"` are external links. You will quit the documentation when       // clicking on it.       \"type\": \"link\",        // The corresponding link       \"link\": \"https://www.example.com/demo/\",        // Name displayed for the link to that directory on the generated HTML pages.       \"displayName\": \"Demo\"     },     {       // Special type which leads to be able to search documentation       // The documentation is automatically generated and is done entirely through       // JavaScript, without relying on external actors.       \"type\": \"search\"     }   ],   \"linksRight\": [     {       // `\"github-link\"` is a special kind of link (with its own logo),       // redirecting to the github link of the project, if one.       //       // Yes, I should probably also either do gitlab, sourcehut etc. or just       // provide some generic mean but this is just a quick project after all       \"type\": \"github-link\",        // Corresponding link       \"link\": \"https://github.com/name/repo\"     },     {       // Special type which displays the current project's version.       // It is optionally clickable depending on if you defined the       // `link` property       \"type\": \"version\"        // Optional link when clicking on the version in the page       // Can be ignored in which case the version is not clickable       \"link\": \"https://example.com/documentation_pages_by_version.html\",     }   ] }  Once you’re done creating one for your project, we can continue by listing all documentation pages inside each categories and its subdirectories.","anchorH1":"configuration","anchorH2":"format-and-properties"}]},{"file":"./Getting_Started/Steps/Page_Ordering.html","index":[{"h1":"Page Listing","body":"","anchorH1":"page-listing"},{"h1":"Page Listing","h2":"Overview","body":"Your documentation pages should be inside the “Categories” directories you configured in your global configuration file (as local-doc links inside either the linksLeft or the linksRight property of it). To let README know how to name your various documentation files and in which order they should be shown, you will now also have to add .docConfig.json files inside all the inner directories where your Markdown documentation pages are found. For example, let’s consider a case where files are put in a doc root directory: doc                                  # Root directory │ ├── .docConfig.json                  # Global configuration │ ├── Getting_Started                  # \"Getting Started\" Category │   ├── .docConfig.json              # Local configuration (we'll see that here) │   ├── Steps                        # Page group │   │   ├── .docConfig.json          # Local configuration │   │   ├── Configuration.md │   │   ├── Documentation_Files.md │   │   ├── Page_Ordering.md │   │   ├── Run.md │   │   └── Serve.md │   ├── Home.md │   └── HTML_Page_features.md │ └── API                              # Another Category, \"API\"     ├── .docConfig.json              # Local configuration     ├── CLI.md     └── ...  Note however that the syntax of those .docConfig.json files is different than the one of the global configuration, that’s what we’ll see here.","anchorH1":"page-listing","anchorH2":"overview"},{"h1":"Page Listing","h2":"Local configurations content","body":"Those “local” .docConfig.json just needs to be given:   The order in which documentation pages should be showned. This is achieved by listing those pages in a pages array property. Pages are listed from top to bottom.   For each page, a link to the Markdown file containing the documentation you want to show, as well as the name with which it should be referred to.   Optionally for page groups (directories), you can indicate if you want this page groups to be opened by default when going to the documentation. If not, the page group will only be opened if either the reader opened it, or if the current visualized page is inside that page group.   Here is a completely annotated example: {   // Documentation pages, that will be linked from top to bottom   \"pages\": [     {       // Relative path to the markdown file.       \"path\": \"./Home.md\",        // Name actually displayed for the link to it on the generated HTML page       \"displayName\": \"Welcome\"     },     {       // Relative path to a subdirectory       \"path\": \"./Steps\",        // Name actually displayed for this directory's title on the generated       // HTML page       \"displayName\": \"Step by step guide\"        // Optionally for page groups (when the path is a directory), you can       // set `defaultOpen` to `true` if you want the page group to be open       // by default.       // This property is set to false by default, meaning that page groups       // are closed by default.       \"defaultOpen\": true,     }     {       \"path\": \"./HTML_Page_features.md\",       \"displayName\": \"Features of the HTML pages\"     }   ] }  You’ll have to add a .docConfig.json file in each directory in which documentation pages are found:   In the “Categories” directories (those behind a local-doc link in the global configuration)   In all the page groups inside those directories (meaning: the subdirectories, which themselves had to be referenced in the .docConfig.json of the corresponding Category)   Let’s see again the example at the top of this page: doc                                  # Root directory │ ├── .docConfig.json                  # Global configuration │ ├── Getting_Started                  # \"Getting Started\" Category │   ├── .docConfig.json              # Local configuration │   ├── Steps                        # Page group │   │   ├── .docConfig.json          # Local configuration │   │   ├── Configuration.md │   │   ├── Documentation_Files.md │   │   ├── Page_Ordering.md │   │   ├── Run.md │   │   └── Serve.md │   ├── Home.md │   └── HTML_Page_features.md │ └── API                              # Another Category, \"API\"     ├── .docConfig.json              # Local configuration     ├── CLI.md     └── ...  You can see in this example that there are three “local configuration” files:   Inside the doc/Getting_Started Category directory   Inside the doc/Getting_Started/Steps page group   Inside the doc/API Category directory  ","anchorH1":"page-listing","anchorH2":"local-configurations-content"}]},{"file":"./Getting_Started/Steps/Run.html","index":[{"h1":"Run","body":"","anchorH1":"run"},{"h1":"Run","h2":"Overview","body":"Now that the documentation is written and that configuration files are added (see previous steps), we can finally generate the documentation’s HTML pages. This can be done in two ways: using the command line interface (CLI) API, or by running it through JavaScript.","anchorH1":"run","anchorH2":"overview"},{"h1":"Run","h2":"Through the CLI","body":"The most straightforward way to run README is through the command line. The readme.doc command (that you installed with the README package), has multiple flags and options. There is two mandatory options:   --input [input] (or -i [input]), with [input] being the root directory where your documentation (in Markdown) resides.   --output [output] (or -o [output]), with [output] being the destination directory where HTML files will be generated. Note that the output directory can be inside the input directory. It’s for example a frequent usage to set a doc input directory and a doc/generated output directory.   There are also two other heavily recommended options:   --clean (or -c): Removes the output directory if it existed previously. Without this option, README will never remove files inside the output directory, which mean it could grow indefinitely if you’re not careful.   --project-version [version] (or -p [version]), with [version] being the current version of your project: Allows to indicate in your documentation pages the version they apply to. If your project is a JavaScript project with a package.json file, you could just rely on the version anounced in that file (e.g. by calling node -e \"console.log(require('./package.json').version)\") to set that property.   For example, if your root directory is doc and you want to generate your HTML documentation in doc/generated, you can run: readme.doc --clean --input doc --output doc/generated  If you’re on a JavaScript project, you can also easily rely programatically on your project’s version anounced in its package.json file: readme.doc --clean --input doc --output doc/generated --project-version $(node -e \"console.log(require('./package.json').version)\") ","anchorH1":"run","anchorH2":"through-the-cli"},{"h1":"Run","h2":"Through the JavaScript API","body":"The JavaScript README module exposes by default a function taking three arguments:  The input directory The output directory The other options, including clean (to remove the output directory if it already existed) and version (the current version of your project)  Here’s an example of how you could call it: import readme from \"@canalplus/readme.doc\";  readme(\"./doc\", \"./doc/generated\", {   clean: true,   version: \"1.2.5\", }); ","anchorH1":"run","anchorH2":"through-the-javascript-api"}]},{"file":"./Getting_Started/Steps/Serve.html","index":[{"h1":"Serve","body":"","anchorH1":"serve"},{"h1":"Serve","h2":"Overview","body":"If you followed all preceding steps, you’ve now finished generating your documentation and their HTML pages now reside in the output directory. You’ll now need to serve those files somewhere so that they can be accessible by your users.","anchorH1":"serve","anchorH2":"overview"},{"h1":"Serve","h2":"Testing locally","body":"You can check locally if you’re satisfied with the generated documentation by just launching an HTTP server serving statically local files. No server is included with README as staying simple and minimal is one of its core goal. However, we frequently rely on http-server for local tests. You may also rely on it by calling: npx http-server  Once your local server is started, go to its URL and navigate to one of your documentation’s HTML page (you may have to navigate your files first). Once on one of the generated HTML page, you’ll be able to see the final result. Note that technically, you could also make your web browser read directly your local files without needing to run an HTTP server. However doing that is not recommended as it may lead to some features not working as intended due to security reasons. As an example, search usually won’t work properly if you’re not going through an HTTP server.","anchorH1":"serve","anchorH2":"testing-locally"},{"h1":"Serve","h2":"Serving the final documentation","body":"If you’re satisfied with it, you can now just deploy the output directory online. Note that all you need is just serving statically the generated file, there’s no further server-side logic than that. As such, free offerings like GitHub pages are fully compatible with README (on that note, the current page is served thanks to that service).","anchorH1":"serve","anchorH2":"serving-the-final-documentation"}]},{"file":"./Getting_Started/HTML_Page_Features.html","index":[{"h1":"Features of the HTML Pages","body":"","anchorH1":"features-of-the-html-pages"},{"h1":"Features of the HTML Pages","h2":"Overview","body":"The HTML pages generated by README should work with or without JavaScript (library users reading documentation pages are full of geeks after all ;)). Yet they have many supplementary features when JavaScript is enabled.","anchorH1":"features-of-the-html-pages","anchorH2":"overview"},{"h1":"Features of the HTML Pages","h2":"Search","body":"Search in README is achieved without involving a third-party thanks to the elastic lunr library. The idea is that an index is generated when your documentation is built, and that index is fetched the first time you search on the generated HTML page. Elastic lunr then searches through that index to provide matches that are then display in the page. Doing the search locally has the advantage of not having to rely on third parties for your search. It also allows to have a much faster search experience than if a server was requested for each search input. Note however that elastic lunr is quite old and that some more recent local search implementations exist that we’re looking at today with the goal of improving search accuracy.","anchorH1":"features-of-the-html-pages","anchorH2":"search"},{"h1":"Features of the HTML Pages","h2":"Soft navigation","body":"Links to other documentation pages, as long as they concern the same category (e.g. you’re switching between links of the API category), are pre-loaded as soon as they are hovered. Because documentation pages are very small in size, doing this has the advantage of leading to an almost instantaneous page change (as the request has often already ended before the link is actually clicked on). The idea of pre-loading pages to then quasi-instantaneously update the page’s content on navigation through JavaScript is a recurrent trick called “soft navigation”. Doing this also has the advantage of keeping the state of your page as is, even when navigating between links. For example, page groups will remain opened even when going to another documentation page.","anchorH1":"features-of-the-html-pages","anchorH2":"soft-navigation"},{"h1":"Features of the HTML Pages","h2":"Responsiveness","body":"This feature doesn’t depend on JavaScript, but it should still be noted that README HTML pages have two layouts depending on the available width. Once small enough, several changes are made when compared to the full-width layout:   A “hamburger button” appears, toggling the display of a list of both the pages in the current category as well as the categories themselves. External links are also shown in that list.   The header now only contains this hamburger button, your logo (if enabled), search (if enabled) and your project’s version (if enabled).   The table of contents (usually on the right side of the screen) is not visible anymore.   This was done to allow a smoother experience when reading your documentation in a case where not a lot of horizontal space is available.","anchorH1":"features-of-the-html-pages","anchorH2":"responsiveness"}]},{"file":"./API/CLI.html","index":[{"h1":"CLI API","body":"","anchorH1":"cli-api"},{"h1":"CLI API","h2":"Preamble","body":"You can interact with README with two ways: with the CLI API (running readme.doc in the command line, through npx or through an npm script) or with the JavaScript API (importing \"readme.doc\" in a JavaScript / TypeScript file). This page is going to focus on the CLI API.","anchorH1":"cli-api","anchorH2":"preamble"},{"h1":"CLI API","h2":"CLI Options","body":"","anchorH1":"cli-api","anchorH2":"cli-options"},{"h1":"CLI API","h2":"CLI Options","h3":"Format","body":"CLI options are means to configure or to give information (such as your documentation’s root directory) to the readme.doc command. They each exist in two possible forms:   A long form, starting with two dashes (--). For example --input   A short single-letter form starting with a single dash -. For example -i, which is equivalent to --input.   Some options need an argument, which has to be added after the option (and separated with it by a space). For example --input takes in argument the documentation root directory as a path: readme.doc --input ./my_root_directory`  Others don’t have any argument, for example --help: readme.doc --help  Options cannot be “combined” behind a single dash, like you may be used to with GNU utils. They have to be separately specified: # This won't work readme.doc -ih ","anchorH1":"cli-api","anchorH2":"cli-options","anchorH3":"format"},{"h1":"CLI API","h2":"CLI Options","h3":"Special options","body":"The readme.doc has two options which will just lead it to output information and exit as soon as the option is encountered:   --help (or -h in short form): displays a list of available commands with a short description. This command doesn’t take any argument.   --version (or -v in short form): displays the current version of the README tool you installed. This command doesn’t take any argument.  ","anchorH1":"cli-api","anchorH2":"cli-options","anchorH3":"special-options"},{"h1":"CLI API","h2":"Mandatory options","body":"For any other cases when none of those options are relied on, you will need to specify at least the following two options:   --input (or -i in short form): To specify your input root directory (where the .docConfig.json global configuration can be found) as this command’s argument.   --output (or -o in short form): To specify the output root directory (where the generated HTML files will be added) as this command’s argument.   Note that it is perfectly valid to set an output inside the input directory. For example, you could want to call readme.doc this way: # This won't work readme.doc --input ./doc --output ./doc/generated ","anchorH1":"cli-api","anchorH2":"mandatory-options"},{"h1":"CLI API","h2":"Recommended supplementary options","body":"The readme.doc command has two supplementary options we heavily recommend you to also use for each documentation generation:   --clean (or -c in short form): Removes the output directory if it existed previously. Without this option, README will never remove files inside the output directory, which mean it could grow indefinitely if you’re not careful. This command doesn’t take any argument.   --project-version (or -p in short form), To specify the current version of your project (in argument of that option), which will thus be indicated in the produced documentation pages. If your project is a JavaScript project with a package.json file, you could just rely on the version anounced in that file (e.g. by calling node -e \"console.log(require('./package.json').version)\") to set that property.  ","anchorH1":"cli-api","anchorH2":"recommended-supplementary-options"},{"h1":"CLI API","h2":"Examples of recommended commands","body":"For example, if your root directory is doc and you want to generate your HTML documentation in doc/generated, you can run: readme.doc --clean --input doc --output doc/generated  If you’re on a JavaScript project, you can also easily rely programatically on your project’s version anounced in its package.json file: readme.doc --clean --input doc --output doc/generated --project-version $(node -e \"console.log(require('./package.json').version)\") ","anchorH1":"cli-api","anchorH2":"examples-of-recommended-commands"},{"h1":"CLI API","h2":"Output","body":"The readme.doc won’t produce any output if the doc could be generated with success. If any error arised which prevented the documentation generation to finish, an error message beginning with [ERROR] explaining the issue will be outputed to stderr. If an error arised but it did not prevent the documentation generation from finishing, an error message beginning with [WARNING] explaining the issue will be outputed to stderr. Even if those do not prevent the documentation generation from finishing, we recommend that you resolve any issue it has seen to ensure a good experience when navigating the generated documentation.","anchorH1":"cli-api","anchorH2":"output"}]},{"file":"./API/JS_API.html","index":[{"h1":"JavaScript API","body":"This documentation page is not yet written. For now, see the Run Documentation in the Getting Started category.","anchorH1":"javascript-api"}]},{"file":"./API/Documentation_Pages.html","index":[{"h1":"Documentation pages","body":"This documentation page is not yet written. For now, see the Page Files documentation in the Getting Started category.","anchorH1":"documentation-pages"}]},{"file":"./API/Configuration.html","index":[{"h1":"Configuration","body":"This documentation page is not yet written. For now, see the Configuration Documentation in the Getting Started category.","anchorH1":"configuration"}]}]